# Decentralized Instant Messaging Protocol (DIMP)

[![license](https://img.shields.io/github/license/mashape/apistatus.svg)](https://github.com/moky/DIMP/blob/master/LICENSE)
[![Version](https://img.shields.io/badge/alpha-0.1.0-red.svg)](https://github.com/moky/DIMP/wiki)

## 0. Abstract
This document introduces a new protocol designed for instant messaging (IM) and an architecture for developing decentralized IM applications. The software provides accounts(user identity recognition) and communications between accounts safely by end-to-end encryption.

It includes just TWO extremely simple parts:

1. User Identify
2. Messaging

Copyright &copy; 2018 Albert Moky

### White papers

- [English](TechnicalWhitePaper.md)
- [Chinese](zh-CN/TechnicalWhitePaper.md)

## 1. User Identify

### 1.0. Meta
The **Meta** was generated by your private key,
it can be used to build a new ID for entity, or verify the ID/PK pair.

The 'Meta' consists of 4 fields:

| Field       | Description                   |
| ----------- | ----------------------------- |
| version     | Meta Algorithm Version        |
| seed        | Entity Name                   |
| key         | Public Key                    |
| fingerprint | Signature to generate address |

```
/* example: hulk@4YeVEN3aUnvC1DNUufCq1bs9zoBSJTzVEj */
{
    version     : 0x01,
    seed        : "hulk",
    key         : {
        algorithm : "RSA", // encrypt: PKCS1, sign: PKCS1v15SHA256
        data      : "-----BEGIN PUBLIC KEY-----\nMIGJAoGBALB+vbUK48UU9rjlgnohQowME+3JtTb2hLPqtatVOW364/EKFq0/PSdnZVE9V2Zq+pbX7dj3nCS4pWnYf40ELH8wuDm0Tc4jQ70v4LgAcdy3JGTnWUGiCsY+0Z8kNzRkm3FJid592FL7ryzfvIzB9bjg8U2JqlyCVAyUYEnKv4lDAgMBAAE=\n-----END PUBLIC KEY-----"
    },
    fingerprint : "jIPGWpWSbR/DQH6ol3t9DSFkYroVHQDvtbJErmFztMUP2DgRrRSNWuoKY5Y26qL38wfXJQXjYiWqNWKQmQe/gK8M8NkU7lRwm+2nh9wSBYV6Q4WXsCboKbnM0+HVn9Vdfp21hMMGrxTX1pBPRbi0567ZjNQC8ffdW2WvQSoec2I="
}
```

THe **fingerprint** field was generated by your **private key** and **seed**:

````
fingerprint = sign(seed, SK);
````

### 1.1. ID
The **ID** is used to identify an **entity**(account/group). It consists of 3 fields:

| Field       | Description                   |
| ----------- | ----------------------------- |
| name        | Same with meta.seed           |
| address     | Unique Identification         |
| terminal    | Login point, it's optional.   |

The ID format is ```name@address[/terminal]```.

```
/* examples */
ID1 = "hulk@4YeVEN3aUnvC1DNUufCq1bs9zoBSJTzVEj"; // Immortal Hulk
ID2 = "moki@4WDfe3zZ4T7opFSi3iDAKiuTnUHjxmXekk"; // Monkey King
```

#### Name
The **Name** field is an entity name (username, or just a random string for group).

1. The length of name must more than 1 byte, less than 32 bytes;
2. It should be composed by a-z, A-Z, 0-9, or charactors '_', '-', '.';
3. It cannot contain key charactors('@', '/').

```
// For example
name = "Albert.Moky";
```

#### Address
The **Address** field was created by the **Meta** info and the **Network ID**:

````
// Network ID
enum {
    MKMNetwork_Main  = 0x08, // (Person)
    MKMNetwork_Group = 0x10, // (Multi-Persons)
};

// Address algorithm
function btcBuildAddress(fingerprint, network) {
    hash       = ripemd160(sha256(fingerprint));
    check_code = sha256(sha256(network + hash)).prefix(4);
    address    = base58(network + hash + code);
    return address;
}
````

### 1.2. Public Key
A **public key** (PK) was binded to an ID by the __Meta Algorithm__,
when you get a meta for the entity ID from the network,
you must verify it with the consensus algorithm before accept it:

```
function isMatch(ID, meta) {
    // 1. check 'seed', 'key' & 'fingerprint' in meta with ID.name
    if (meta.seed != ID.name) {
        return false;
    }
    if (verify(meta.seed, meta.fingerprint, meta.key)) {
        return false;
    }
    
    // 2. build address with meta, compare it with ID.address
    address = btcBuildAddress(meta.fingerprint, ID.address.network);
    if (address != ID.address) {
        return false;
    }
    
    // 3. if all of the above matches, get public key from meta
    ID.publicKey = meta.key;
    return true;
}
```

### 1.3. Entity (Account/Group)
**Entity** is the sender/receiver in the network communication.

An entity can be an account or a group. It has an **ID**, a **name**, and a **number** for searching.

An **account** will have a **public key**.

A **group** will have **founder**, **owner** and **members**.

```
// create account
user = new Account(accountID, accountPK);

// create group
group = new Group(groupID, founderID);
```

## 2. Messaging

### 2.0. Envelope

```
{
    sender   : "moki@4WDfe3zZ4T7opFSi3iDAKiuTnUHjxmXekk",
    receiver : "hulk@4YeVEN3aUnvC1DNUufCq1bs9zoBSJTzVEj",
    time     : 1544106533
}
```

### 2.1. Message Content

````
{
    type     : 0x01,       // message type
    sn       : 1544106533, // serial number (message ID in conversation)
    
    text     : "Hey guy!"
}
````

#### Message Type

````
enum {
    DIMMessageType_Unknown = 0x00,
    
    DIMMessageType_Text    = 0x01,
    
    DIMMessageType_File    = 0x10,
    DIMMessageType_Image   = 0x12, // photo
    DIMMessageType_Audio   = 0x14, // voice
    DIMMessageType_Video   = 0x16,
    
    DIMMessageType_Page    = 0x20, // web page
    
    // quote an exists message and reply it with text
    DIMMessageType_Quote   = 0x37,
    
    // system command
    DIMMessageType_Command = 0x88,
    
    // top-secret message forwarded by proxy(account or station)
    DIMMessageType_Forward = 0xFF
};
````

### 2.2. Message

When the user want to send out a message, the client needs TWO steps before sending it:

1. encrypt the **Instant Message** to **Secure Message**;
2. sign the **Secure Message** to **Reliable Message**.

Similarly, when the client received a message, it needs TWO steps to extract the content:

1. verify the **Reliable Message** to **Secure Message**;
2. decrypt the **Secure Message** to **Instant Message**.

#### Instant Message

````
{
    //-------- head (envelope) --------
    sender   : "moki@4WDfe3zZ4T7opFSi3iDAKiuTnUHjxmXekk",
    receiver : "hulk@4YeVEN3aUnvC1DNUufCq1bs9zoBSJTzVEj",
    time     : 1544106533,
    
    //-------- body (content) ---------
    content  : {
        type : 0x01,       // message type
        sn   : 1544106533, // serial number (ID)
        text : "Hey guy!"
    }
    
}
````

content -> JsON string: ```{"sn":1544106533,"text":"Hey guy!","type":1}```

#### Secure Message

```
/**
 *  Algorithm:
 *      string = json(content);
 *      PW     = random();
 *      data   = encrpyt(string, PW);      // Symmetric
 *      key    = encrypt(PW, receiver.PK); // Asymmetric
 */
{
    //-------- head (envelope) --------
    sender   : "moki@4WDfe3zZ4T7opFSi3iDAKiuTnUHjxmXekk",
    receiver : "hulk@4YeVEN3aUnvC1DNUufCq1bs9zoBSJTzVEj",
    time     : 1544106533,
    
    //-------- body (content) ---------
    data     : "1e8OshcP8Z1XBf49ABJkTGNbIVWS8HjD2DCVEv7HmzMv4LqMKdZBSr4wvf4lXrAk",
    key      : "MnaepvMge7eSSKGeYr2YYblvQr3DPVb3xe3HBC4u5BScusHydQ4/lx0Vl3rvzC3uLMdGVN+BG4qmjYYt53hLSCJhwfwwLynuw/ldSeABQG9t0ObKHnpgAwkvchfDINs2ssz6QgD9bDuV1WzwH49ycNTr84Wa12vXzjERJYalpvw="
}
```

#### Reliable Message

```
/**
 *  Algorithm:
 *      ...
 *      digest    = sha256(sha256(data));
 *      signature = sign(digest, sender.SK);
 */
{
    //-------- head (envelope) --------
    sender   : "moki@4WDfe3zZ4T7opFSi3iDAKiuTnUHjxmXekk",
    receiver : "hulk@4YeVEN3aUnvC1DNUufCq1bs9zoBSJTzVEj",
    time     : 1544106533,
    
    //-------- body (content) ---------
    data      : "1e8OshcP8Z1XBf49ABJkTGNbIVWS8HjD2DCVEv7HmzMv4LqMKdZBSr4wvf4lXrAk",
    key       : "MnaepvMge7eSSKGeYr2YYblvQr3DPVb3xe3HBC4u5BScusHydQ4/lx0Vl3rvzC3uLMdGVN+BG4qmjYYt53hLSCJhwfwwLynuw/ldSeABQG9t0ObKHnpgAwkvchfDINs2ssz6QgD9bDuV1WzwH49ycNTr84Wa12vXzjERJYalpvw=",
    signature : "oKcdCzYfysL5CJNCkgRUfeiRGG5AfEWc6GPerLafUbFWW+sij1codi3kZCiHiBlC4Ya4D/I+2xST78A0GME8P1b//LRP+/4Lh8tOE4qRPjj/G8eWSXvjsLkRbjiLeNmNHiD74BR84/Q0d18T0dlP5hQ30DzBKzauZzrhMas89kc="
}
```


---
Version 0.1 by [Albert Moky](http://moky.github.com/) [Sun Nov 11 23:18:08 CST 2018]
